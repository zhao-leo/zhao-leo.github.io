[{"content":"将ChatGLM以SSE模式代理到本地\r事情的起因是Zotero的插件Awesome GPT只支持/v1/chat/completions路径访问，而ChatGLM的API是https://open.bigmodel.cn/api/paas/v4/,因此只能出此下策，将端口代理到本地，然后通过localhost访问，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 \u0026#39;\u0026#39;\u0026#39; Author: zhao-leo 18055219130@163.com Date: 2024-10-09 18:17:52 LastEditTime: 2024-10-09 20:13:55 \u0026#39;\u0026#39;\u0026#39; import requests from flask import Flask, request, Response import argparse import os import socket # 创建一个命令行参数解析器 解析一个端口参数 argparser = argparse.ArgumentParser(description=\u0026#39;ChatGLM Proxy\u0026#39;) argparser.add_argument(\u0026#39;--port\u0026#39;, type=int, default=None, help=\u0026#39;Proxy server port\u0026#39;) # 查找一个开放的端口 def find_open_port(): with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.bind((\u0026#39;\u0026#39;, 0)) return s.getsockname()[1] # 从环境变量中读取端口，如果未设置则随机选择一个开放的端口 PORT = int(os.getenv(\u0026#39;CHATGLM_PROXY_PORT\u0026#39;, find_open_port())) app = Flask(__name__) TARGET_URL = \u0026#34;https://open.bigmodel.cn/api/paas/v4/chat/completions\u0026#34; # 替换为你的目标 URL @app.route(\u0026#39;/v1/chat/completions\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def proxy_request(): # 从请求头中获取 Authorization auth_header = request.headers.get(\u0026#39;Authorization\u0026#39;) # 从请求体中获取 JSON 数据 json_data = request.get_json() # 构造代理请求 headers = { \u0026#39;Authorization\u0026#39;: auth_header, \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; } # 发送请求到目标 URL response = requests.post(TARGET_URL, headers=headers, json=json_data, stream=True) # 定义一个生成器，逐块返回响应内容 def generate(): for chunk in response.iter_content(chunk_size=1024): if chunk: yield chunk # 返回响应，设置为 SSE 格式 return Response(generate(), content_type=\u0026#39;text/event-stream\u0026#39;) # 优先级 1: 命令行参数 2: 环境变量 3: 默认端口 args = argparser.parse_args() port = args.port if args.port else PORT # 启动服务器 app.run(port=port) ","date":"2024-10-08T00:00:00Z","image":"https://www.zhaocloud.work/p/chatglm_proxy/cover_hu7161ee58408898193b62149ad34cf790_94738_120x120_fill_box_smart1_3.png","permalink":"https://www.zhaocloud.work/p/chatglm_proxy/","title":"ChatGLM代理到本地"},{"content":"Step1：让你在课上的[好友] 冤种 拍一张二维码发给你\rStep2：用微信自带扫一扫打开，将结果直接发给你填入下面的格子中\rStep3：点击按钮，然后用BUPT企业号扫码\r开始生成二维码\r","date":"2024-09-22T00:00:00Z","image":"https://www.zhaocloud.work/p/bupt_class/cover_hu1de54da1f76d705a778754046d4bf0fc_511478_120x120_fill_q75_box_smart1.jpg","permalink":"https://www.zhaocloud.work/p/bupt_class/","title":"BUPT课堂打卡二维码生成器"},{"content":"姐姐和猫猫的歌\r感谢姐姐在闲暇之时为猫猫唱的歌啦~ ","date":"2024-09-04T00:00:00Z","image":"https://www.zhaocloud.work/p/sister_songs/cover_hu70df2218e38fb144a88b79274cb003bf_151138_120x120_fill_q75_h2_box_smart1_2.webp","permalink":"https://www.zhaocloud.work/p/sister_songs/","title":"姐姐和猫猫的歌"},{"content":"在windows下安装mingw版本的Rust\r事前准备\r确保你的电脑安装了MinGW-64,可以使用以下命令：\n1 gcc --version 应当有类似如下的结果:\n1 2 3 4 gcc (MinGW-W64 x86_64-msvcrt-posix-seh, built by Brecht Sanders) 13.2.0 Copyright (C) 2023 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 下载Rust安装程序\r下载GNU版本的Rust安装程序： Windows-GNU版本\n运行rustup-init.exe\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Rust Visual C++ prerequisites Rust requires a linker and Windows API libraries but they don\u0026#39;t seem to be available. These components can be acquired through a Visual Studio installer. 1) Quick install via the Visual Studio Community installer (free for individuals, academic uses, and open source). 2) Manually install the prerequisites (for enterprise and advanced users). 3) Don\u0026#39;t install the prerequisites (if you\u0026#39;re targeting the GNU ABI). \u0026gt; 在这一步选择3，然后Enter\n得到如下页面:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 Welcome to Rust! This will download and install the official compiler for the Rust programming language, and its package manager, Cargo. Rustup metadata and toolchains will be installed into the Rustup home directory, located at: D:\\environment\\rustup This can be modified with the RUSTUP_HOME environment variable. The Cargo home directory is located at: D:\\environment\\cargo This can be modified with the CARGO_HOME environment variable. The cargo, rustc, rustup and other commands will be added to Cargo\u0026#39;s bin directory, located at: D:\\environment\\cargo\\bin This path will then be added to your PATH environment variable by modifying the HKEY_CURRENT_USER/Environment/PATH registry key. You can uninstall at any time with rustup self uninstall and these changes will be reverted. Current installation options: default host triple: x86_64-pc-windows-msvc default toolchain: stable (default) profile: default modify PATH variable: yes 1) Proceed with standard installation (default - just press enter) 2) Customize installation 3) Cancel installation \u0026gt; 如果你要把Rust安装在其他位置，一定要根据提示修改系统环境变量RUSTUP_HOME和CARGO_HOME\n在这一步选择2，然后Enter\n有如下内容：\n1 2 3 4 I\u0026#39;m going to ask you the value of each of these installation options. You may simply press the Enter key to leave unchanged. Default host triple? [x86_64-pc-windows-msvc] 注意!!! 键入如下内容:\n1 x86_64-pc-windows-gnu 其他选项不要修改，一路Enter即可。\n最后你的页面应该如下：\n1 2 3 4 5 6 7 8 9 10 11 Current installation options: default host triple: x86_64-pc-windows-gnu default toolchain: stable profile: default modify PATH variable: yes 1) Proceed with selected options (default - just press enter) 2) Customize installation 3) Cancel installation 最后回车一次，等待程序自动运行即可。\n","date":"2024-08-29T00:00:00Z","image":"https://www.zhaocloud.work/p/rust_installation/cover_hu45a5e3ad5e058da6a00650ed8fd40bea_15530_120x120_fill_q75_box_smart1.jpg","permalink":"https://www.zhaocloud.work/p/rust_installation/","title":"在windows下安装mingw版本的Rust"},{"content":"北邮Matlab选修 期末作业\r题目 #1\r问题描述\r对于自由降落的伞兵，其阻力为线性函数，速度的解析表达式为： $$v\\left(t\\right)=\\frac{gm}{c}\\left(1-e^{-\\frac{c}{m}t}\\right)$$ 其中v(t)是速度$m/s$，t是时间$s$，$g=9.81m/s^2$，m是质量(kg)，c是线性阻力系数$kg/s$。使用数值积分算法计算跳伞员在自由落体最初的8秒内下降的高度。给定$m=80kg$，$c=10kg/s$\n数学模型\r对于给定的$v\\left(t\\right)$，在时间从$t_0$到$t_1$时行过的路程： $$x=\\int_{t_0}^{t_1}v\\left(t\\right)dt$$\n为了求自由落体最初的8秒内下降的高度，即求$\\int_{0}^{8}v\\left(t\\right)dt$的数值。\n程序设计\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 %question1.m % 定义参数 g = 9.81; % 重力加速度，单位 m/s^2 m = 80; % 质量，单位 kg c = 10; % 线性阻力系数，单位 kg/s % 定义符号变量 syms t % 速度函数 v = g*m/c * (1 - exp(-c/m*t)); % 定义时间向量，这里我们使用足够小的时间间隔来确保积分的准确性 t_span = 0:0.001:8; % 从0秒到8秒，步长为0.01秒 % 计算对应时间点的速度值 v_values = double(subs(v, t, t_span)); % 将符号表达式替换为数值，并转换为双精度浮点数 % 使用梯形法计算位移（即高度），初始高度设为0 % 注意：这里的高度实际上是相对于初始位置的位移，因此初始值设置为0 height_increase = trapz(t_span, v_values); % trapz函数计算的是增量，所以结果就是从0开始的位移 % 输出结果 fprintf(\u0026#39;跳伞员在最初的8秒内下降的高度为:%.2f m\\n\u0026#39;, height_increase); 计算结果\r1 2 \u0026gt;\u0026gt; question1 跳伞员在最初的8秒内下降的高度为:230.97 m 题目 #2\r问题描述\r在加热盘的不同点上测量温度如下表所示。估计下面各点的温度：（a）$x=4$，$y=3.2$；（b）$x=4.3$，$y=2.7$。\n$x=0$\r$x=2$\r$x=4$\r$x=6$\r$x=8$\r$y=0$\r100.00\r90.00\r80.00\r70.00\r60.00\r$y=2$\r85.00\r64.49\r53.50\r48.15\r50.00\r$y=4$\r70.00\r48.90\r38.43\r35.03\r40.00\r$y=6$\r55.00\r38.78\r30.39\r27.07\r30.00\r$y=8$\r40.00\r35.00\r30.00\r25.00\r20.00\r数学模型\r题目中给定了有限的温度取样点，要得知a和b点的温度，需要我们根据给定点的温度进行插值，如果采用线性插值，显然不符合事实， 这里我选择三次样条插值，使结果更加平滑。\n程序设计\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 %question2.m % 定义x和y的网格点 [x_grid, y_grid] = meshgrid(0:2:8, 0:2:8); % 温度矩阵（索引从1开始，与x_grid和y_grid匹配） T = [ 100.00,90.00,80.00,70.00,60.00; 85.00,64.49,53.50,48.15,50.00; 70.00,48.90,38.43,35.03,40.00; 55.00,38.78,30.39,27.07,30.00; 40.00,35.00,30.00,25.00,20.00 ]; % 创建一个更精细的网格用于绘图 [xq, yq] = meshgrid(0:0.01:8, 0:0.01:8); % 使用线性插值估计温度 Tq_spline = interp2(x_grid, y_grid, T, xq, yq,\u0026#34;spline\u0026#34;); % 估计特定点的温度 point_a_x = 4; point_a_y = 3.2; point_b_x = 4.3; point_b_y = 2.7; % 使用interp2函数估计温度 temp_a = interp2(x_grid, y_grid, T, point_a_x, point_a_y, \u0026#39;spline\u0026#39;); temp_b = interp2(x_grid, y_grid, T, point_b_x, point_b_y, \u0026#39;spline\u0026#39;); % 显示估计的温度 fprintf(\u0026#39;点(a)x=4, y=3.2 的温度估计为：%.2f°C\\n\u0026#39;, temp_a); fprintf(\u0026#39;点(b)x=4.3, y=2.7 的温度估计为：%.2f°C\\n\u0026#39;, temp_b); % 绘制二维彩色网格图 pcolor(xq, yq, Tq_spline); % 使用pcolor绘制二维彩色网格图 shading interp; % 平滑颜色过渡 % 设置颜色映射 colormap(\u0026#39;jet\u0026#39;); % 添加颜色条 colorbar; % 添加坐标轴标签和标题 xlabel(\u0026#39;X坐标\u0026#39;); ylabel(\u0026#39;Y坐标\u0026#39;); title(\u0026#39;温度分布二维图像\u0026#39;); % 可以在图上添加估计点的标记 hold on; plot(point_a_x, point_a_y, \u0026#39;r*-\u0026#39;); % 点（a）红色 plot(point_b_x, point_b_y, \u0026#39;b*-\u0026#39;); % 点（b）绿色 hold off; 计算结果\r1 2 3 \u0026gt;\u0026gt; question2 点(a)x=4, y=3.2 的温度估计为：43.45°C 点(b)x=4.3, y=2.7 的温度估计为：46.15°C ","date":"2024-08-05T00:00:00Z","permalink":"https://www.zhaocloud.work/p/matlab_final/","title":"Matlab 期末作业"},{"content":"北邮Matlab选修 期中作业\r题目 #1\r问题描述\r下图给出了一个用管道连接的三个反应的系统。如图所示，化学物质通过每个管道传输的速率等于流率Q(单位为$m^3/s$)乘以导致流动的反应浓度c(单位为$mg/m^3$)。如果系统状态稳定，则每个反应输入的化学物质和输出的达到平衡。为每个反应构建质量平衡方程，并求解得到它们的浓度。\n数学模型\r数学关系\r对于所有的反应，在稳定状态时，都有流入的速率等于流出的速率，以此为基础，可以得到三个方程如下：\n反应 #1\n$$ 500+Q_{21}c_2 = Q_{12}c_1 + Q_{13}c_1 $$\n反应 #2\n$$ Q_{12}c_1=Q_{21}c_2+Q_{23}c_2 $$\n反应 #3\n$$ 500 + Q_{13}c_1+Q{23}c_2=Q_{33}c_3 $$\n化简并得到对应方程\r其中：\n$ Q_{33}=120$,$Q_{13}=40$,$Q_{23}=60$,$Q_{21}=30$\r替换并转化成矩阵形式如下：\n程序设计\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 %Guass.m function [U,x]=Gauss(A,b) % 顺序Gauss消去法求解线性方程组 % 输入参数： %---A：线性方程组的系数矩阵 %---b：线性方程组的右端项 % 输出参数： % %---U：消元后的上三角方程组的增广矩阵---x：线性方程组的解 n=length(b); % 消元过程 for k=1:n-1 % 消元成上三角矩阵 m=A(k+1:n,k)/A(k,k); A(k+1:n,k+1:n)=A(k+1:n,k+1:n)-m*A(k,k+1:n); b(k+1:n)=b(k+1:n)-m*b(k); A(k+1:n,k)=zeros(n-k,1); end U=[A,b]; % 回代过程 x=zeros(n,1); x(n)=b(n)/A(n,n); % 求x_n for k=n-1:-1:1 % 回代 x(k)=(b(k)-A(k,k+1:n)*x(k+1:n))/A(k,k); % 求 x_k，k=n-1,n-2,…,1 end 计算结果\r1 2 3 4 5 %test1.m A=[130,-30,0;90,-90,0;40,60,-120]; b=[500;0;-500]; [U,c]=Gauss(A,b); disp(c); 1 2 3 4 \u0026gt;\u0026gt; test1 5.0000 5.0000 8.3333 题目 #2\r问题描述\r下面给出了一个迭代模型：\n写出求解该模型的M函数。如果迭代初值为$x_0=y_0=0$，那么，进行30000次迭代求出一组$x$和$y$向量，然后在所有的$x_k$和$y_k$坐标处画一个点（注意不要连线），最后绘制出所需的图形（说明：这样绘制出的图形称为Henon引力线图，它将迭代出来的随机点吸引到一起，最后得出貌似连贯的引力线图）。\n程序设计\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 %Henon.m function XY=Henon(x0,y0,N) % Henon引力线 % 输入参数： % %---x0：迭代初始值-x0 %---y0：迭代初始值-y0 %---N：迭代次数 % 输出参数： % %---XY：Henon引力线的点坐标 x=x0; y=y0; % 初始化存储结果的矩阵，第一行存储初始值 XY = [x0, y0]; % 迭代模型 for k = 1:N % 更新x和y的值 x_new = 1 + y - 1.4 * x^2; y_new = 0.3 * x; % 将新的x和y值添加到矩阵的下一行 XY = [XY; x_new, y_new]; x=x_new; y=y_new; end % 绘制Henon引力线图 figure; plot(XY(:,1), XY(:,2), \u0026#39;.\u0026#39;); % 绘制点，不连线 title(\u0026#39;Henon引力线图\u0026#39;); 计算结果\r1 2 3 4 %test2.m x0=0;y0=0;%定义初始值 N=30000;%迭代次数 XY=Henon(x0,y0,N);%调用函数 1 \u0026gt;\u0026gt; test2 ","date":"2024-08-05T00:00:00Z","permalink":"https://www.zhaocloud.work/p/matlab_midterm/","title":"Matlab 期中作业"},{"content":"北邮Matlab选修 Week 9 插值(升级版)\r插值计算\r问题描述\r已知如下函数表，利用牛顿插值计算 $f(1.5)$：\n$x$\r-1\r1\r2\r3\r$f(x)$\r3\r4\r6\r5\r程序设计\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 %lagrange_interp.m function y=lagrange_interp(xdata,ydata,x) % Lagrange 插值 % 输入参数： % ---xdata：给定的节点横坐标 % ---ydata：给定的节点纵坐标 % ---x：需要进行插值的节点横坐标 % 输出参数： % ---y：Lagrange 插值函数在 x 处的函数值 % = n=length(xdata); m=length(ydata); if n~=m error(\u0026#39;插值数据长度不等！\u0026#39;); end ii=1:n; y=zeros(size(x)); for i=ii ij=find(ii~=i);V=1; % if sum(abs(xdata(i)-xdata(ij))\u0026lt;eps)\u0026gt;0 % error() % end for j=1:length(ij) if abs(xdata(i)-xdata(ij(j)))\u0026lt;eps error(\u0026#39;输入的 n+1 个节点不是互异的。\u0026#39;); end V=V.*(x-xdata(ij(j))); end %prod(x-xdata(ij)\u0026#39;) y=y+V*ydata(i)/prod(xdata(i)-xdata(ij)); end 计算结果\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 %question1.m x=-1.5:0.01:5.2; % 加密数据点 xdata=[-1,1,2,3]; % 已知数据点 ydata=[3,4,6,5]; % 点 xdata 处的函数值 y=lagrange_interp(xdata,ydata,x); % Lagrange 插值 % 计算在 x = 1.5 处的预测值 x_pred = 1.5; y_pred = lagrange_interp(xdata,ydata,x_pred); % 绘制图形 figure; % 创建新的图形窗口 plot(xdata,ydata,\u0026#39;ko\u0026#39;,\u0026#39;MarkerSize\u0026#39;,10,\u0026#39;LineWidth\u0026#39;,2); % 绘制原始数据点，设置点的大小和线宽 hold on; % 保持当前图形，以便在同一图形上添加更多的线或点 plot(x,y,\u0026#39;r\u0026#39;,\u0026#39;LineWidth\u0026#39;,2); % 绘制拉格朗日插值的结果，设置线的颜色和线宽 plot(x_pred,y_pred,\u0026#39;bo\u0026#39;,\u0026#39;MarkerSize\u0026#39;,10,\u0026#39;LineWidth\u0026#39;,2); % 绘制预测点，设置点的颜色、大小和线宽 text(x_pred,y_pred,sprintf(\u0026#39;(%0.1f, %0.2f)\u0026#39;,x_pred,y_pred),\u0026#39;VerticalAlignment\u0026#39;,\u0026#39;bottom\u0026#39;); % 在图上显示预测值 hold off; % 取消保持图形 % 添加标题和轴标签 title(\u0026#39;Lagrange Interpolation\u0026#39;); xlabel(\u0026#39;x\u0026#39;); ylabel(\u0026#39;y\u0026#39;); 1 \u0026gt;\u0026gt; question1 代码修改\r问题描述\r书上给的牛顿插值函数 newton 代码示例中，利用矩阵来记录差商表。但注意到，牛顿插值中实际上只用到了差商表第一行上的元素，因此，只保留第一行元素就够了，其它中间结果并不需保存。请编写一个函数，用于求该磁盘的体积和面积，并用一个实例对编写的函数进行测试。请对书上给出的 newton 代码进行修改：\n1.将数据合规性检查挪到函数代码执行顺序的前方位置，独立于插值计算； 2.修改 newton 函数，用向量来表示差商表中第一行数据的存储。 完成以上代码修改后，计算作业 1 ，检验程序是否正确。\n程序设计\r原代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 %newton_interp.m function [y,D]=newton_interp(xdata,ydata,x) % Newton 插值 % 输入参数： % ---xdata：给定的节点横坐标 % ---ydata：给定的节点纵坐标 % ---x：需要进行插值的节点横坐标 % 输出参数： % ---y：Newton 插值函数在 x 处的函数值 % ---D：差商表 n=length(xdata); m=length(ydata); if n~=m error(\u0026#39;插值数据长度不等！\u0026#39;); end D=zeros(n);D(:,1)=ydata\u0026#39;;H=1; for j=1:n-1 for k=1:n-j if abs(xdata(j+k)-xdata(k))\u0026lt;eps error(\u0026#39;输入的 n+1 个节点不是互异的。\u0026#39;); end D(k,j+1)=(D(k+1,j)-D(k,j))/(xdata(j+k)-xdata(k)); end H=H.*(x-xdata(j)); L(j,:)=H; end L=[ones(size(x));L]; y=L.*repmat(D(1,:)\u0026#39;,1,length(x)); y=sum(y); 改进后的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 %newton_interp_advanced.m function [y,D]=newton_interp_advanced(xdata,ydata,x) % Newton 插值 % 输入参数： % ---xdata：给定的节点横坐标 % ---ydata：给定的节点纵坐标 % ---x：需要进行插值的节点横坐标 % 输出参数： % ---y：Newton 插值函数在 x 处的函数值 % ---D：差商表 n = length(xdata); if n ~= length(ydata) error(\u0026#39;插值数据长度不等！\u0026#39;); end for i = 1:n-1 if abs(xdata(i+1) - xdata(i)) \u0026lt; eps error(\u0026#39;输入的 n+1 个节点不是互异的。\u0026#39;); end end D = ydata; H = 1; L = zeros(n-1, length(x)); % 预先分配 L 的大小 for j = 1:n-1 for k = n:-1:j+1 D(k) = (D(k) - D(k-1)) / (xdata(k) - xdata(k-j)); end H = H .* (x - xdata(j)); L(j,:) = H; end L=[ones(size(x));L]; y=L.*repmat(D(1,:)\u0026#39;,1,length(x)); y=sum(y); 计算结果\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 %question2_newton.m x=-1.5:0.01:5.2; % 加密数据点 xdata=[-1,1,2,3]; % 已知数据点 ydata=[3,4,6,5]; % 点 xdata 处的函数值 y=newton_interp(xdata,ydata,x); % Lagrange 插值 % 计算在 x = 1.5 处的预测值 x_pred = 1.5; y_pred = newton_interp(xdata,ydata,x_pred); % 绘制图形 figure; % 创建新的图形窗口 plot(xdata,ydata,\u0026#39;ko\u0026#39;,\u0026#39;MarkerSize\u0026#39;,10,\u0026#39;LineWidth\u0026#39;,2); % 绘制原始数据点，设置点的大小和线宽 hold on; % 保持当前图形，以便在同一图形上添加更多的线或点 plot(x,y,\u0026#39;r\u0026#39;,\u0026#39;LineWidth\u0026#39;,2); % 绘制拉格朗日插值的结果，设置线的颜色和线宽 plot(x_pred,y_pred,\u0026#39;bo\u0026#39;,\u0026#39;MarkerSize\u0026#39;,10,\u0026#39;LineWidth\u0026#39;,2); % 绘制预测点，设置点的颜色、大小和线宽 text(x_pred,y_pred,sprintf(\u0026#39;(%0.1f, %0.2f)\u0026#39;,x_pred,y_pred),\u0026#39;VerticalAlignment\u0026#39;,\u0026#39;bottom\u0026#39;); % 在图上显示预测值 hold off; % 取消保持图形 % 添加标题和轴标签 title(\u0026#39;Newton Interpolation\u0026#39;); xlabel(\u0026#39;x\u0026#39;); ylabel(\u0026#39;y\u0026#39;); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 %question2_newton_advanced.m x=-1.5:0.01:5.2; % 加密数据点 xdata=[-1,1,2,3]; % 已知数据点 ydata=[ 3,4,6,5]; % 点 xdata 处的函数值 y=newton_interp_advanced(xdata,ydata,x); % Lagrange 插值 % 计算在 x = 1.5 处的预测值 x_pred = 1.5; y_pred = newton_interp_advanced(xdata,ydata,x_pred); % 绘制图形 figure; % 创建新的图形窗口 plot(xdata,ydata,\u0026#39;ko\u0026#39;,\u0026#39;MarkerSize\u0026#39;,10,\u0026#39;LineWidth\u0026#39;,2); % 绘制原始数据点，设置点的大小和线宽 hold on; % 保持当前图形，以便在同一图形上添加更多的线或点 plot(x,y,\u0026#39;r\u0026#39;,\u0026#39;LineWidth\u0026#39;,2); % 绘制拉格朗日插值的结果，设置线的颜色和线宽 plot(x_pred,y_pred,\u0026#39;bo\u0026#39;,\u0026#39;MarkerSize\u0026#39;,10,\u0026#39;LineWidth\u0026#39;,2); % 绘制预测点，设置点的颜色、大小和线宽 text(x_pred,y_pred,sprintf(\u0026#39;(%0.1f, %0.2f)\u0026#39;,x_pred,y_pred),\u0026#39;VerticalAlignment\u0026#39;,\u0026#39;bottom\u0026#39;); % 在图上显示预测值 hold off; % 取消保持图形 % 添加标题和轴标签 title(\u0026#39;Newton Interpolation Advanced\u0026#39;); xlabel(\u0026#39;x\u0026#39;); ylabel(\u0026#39;y\u0026#39;); 1 2 \u0026gt;\u0026gt; question2_newton \u0026gt;\u0026gt; question2_newton_advanced ","date":"2024-08-05T00:00:00Z","permalink":"https://www.zhaocloud.work/p/matlab_interrupt_advanced/","title":"第九周作业-插值升级版"},{"content":"北邮Matlab选修 Week 7 线性方程组求解\r从课程所讲授的线性方程组求解方法中任选一种方法实现对下面的线性方程组的求解\r问题描述\r解方程\n程序设计\r1 2 3 4 5 6 7 8 9 10 11 12 %solveByCramer.m function x = solveByCramer(A, b) n = length(b); x = zeros(n, 1); detA = det(A); for i = 1:n Ai = A; Ai(:,i) = b; x(i) = det(Ai) / detA; end end 计算结果\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026gt;\u0026gt; A=[1,2,3,4;4,3,2,1;1,3,2,4;4,1,3,2] A = 1 2 3 4 4 3 2 1 1 3 2 4 4 1 3 2 \u0026gt;\u0026gt; b=[5;4;3;2] b = 5 4 3 2 \u0026gt;\u0026gt; result=solveByCramer(A,b) result = -1.8000 1.8667 3.8667 -2.1333 电路问题\r问题描述\r一种大型输电网络可以简化为下图所示电路，其中$R_i$表示负载电阻，$r_i$表示线路内阻，设电源电压为$V$。若$R_i=6$，$r_i=1$，$V=18$，求出各个负载上的电流$I_1,I_2,I_3, \\cdots , I_n$及总电流$I_0$。\n数学模型\r物理关系\r对于支路电源和$R_1$，$r_1$，有： $$ V=U_{R_1}+U_{r_1} $$\n即： $$ V=I_1 \\times R_1 + I_0 \\times r_1 $$\n可化为： $$ I_0+6 I_1 = 18 $$ (共 1 个方程)\n对于支路$R_{k+1}$，$r_{k+1}$，$R_k$，有： $$ U_{R_k}=U_{R_{k+1}}+U_{r_{k+1}} (1 \\leq k \u0026lt; n) $$\n即： $$ I_k \\times R_k = I_{k+1} \\times R_{k+1} + \\sum_{j=k+1}^{n} I_j \\times r_k $$\n可化为： $$ -6I_k+7I_{k+1}+\\sum_{j=k+2}^{n} I_j = 0 $$ (共 n-1 个方程)\n根据电流关系，有： $$ I_0=\\sum_{j=1}^{n} I_j $$ (共 1 个方程)\n以上共计n+1个方程，对应$I_0$到$I_n$n+1个未知数。\n转化成数学问题\r转化成矩阵运算：\n解以上方程组可得解向量$I_0$~$I_n$\n程序设计\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 %Circuit.m function result = Circuit(n) % -6*x_{k} + 7*x_{k+1} + (x_{k+2} + x_{k+3} + ... + x_{n}) = 0 A = zeros(n+1, n+1); b = zeros(n+1, 1); b(n+1) = 18; % Fill in the matrix A according to the recursive relation for k = 2:n A(k, k) = -6; A(k, k+1) = 7; if k+2 \u0026lt;= n+1 A(k, k+2:n+1) = 1; end end A(1,1)=1; A(1,2:n+1)=-1; A(n+1,1)=1; A(n+1,2)=6; result = solveByCramer(A,b); end function x = solveByCramer(A, b) n = length(b); x = zeros(n, 1); detA = det(A); for i = 1:n Ai = A; Ai(:,i) = b; x(i) = det(Ai) / detA; end end 计算结果\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026gt;\u0026gt; Circuit(10) ans = 5.9970 2.0005 1.3344 0.8907 0.5955 0.3995 0.2702 0.1858 0.1324 0.1011 0.0867 ","date":"2024-08-05T00:00:00Z","permalink":"https://www.zhaocloud.work/p/matlab_equations/","title":"第七周作业-线性方程组求解"},{"content":"北邮Matlab选修 Week 12 拟合\r拟合函数\r问题描述\r设$f(x)=xe^x,x \\in [0,1.5]$，求$f(x)$的三次近似最佳平方逼近多项式。\n程序设计\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 %question1.m x0=[10;10;10;10];%初始参数猜测值 xdata=linspace(0,1.5,5000);%生成x数据点 ydata=xdata.*exp(xdata);%生成对应的y数据点 %定义函数模型 fun=@(x,xdata)x(1)*xdata.^3+x(2)*xdata.^2+x(3)*xdata+x(4); [x,resnorm]=lsqcurvefit(fun,x0,xdata,ydata); %打印出拟合的参数 disp([\u0026#39;拟合的参数:a=\u0026#39;,num2str(x(1)),\u0026#39;,b=\u0026#39;,num2str(x(2)),\u0026#39;,c=\u0026#39;,num2str(x(3)),\u0026#39;,d=\u0026#39;,num2str(x(4))]); disp([\u0026#39;拟合的方程:\u0026#39;,num2str(x(1)),\u0026#39;*x^3+\u0026#39;,num2str(x(2)),\u0026#39;*x^2+\u0026#39;,num2str(x(3)),\u0026#39;*x+\u0026#39;,num2str(x(4))]); %绘制图形 plot(xdata,fun(x,xdata),\u0026#39;r-\u0026#39;,xdata,ydata,\u0026#39;b--\u0026#39;); %添加图例和标题 legend(\u0026#39;拟合曲线\u0026#39;,\u0026#39;原始数据\u0026#39;); title(\u0026#39;使用lsqcurvefit拟合的曲线\u0026#39;); xlabel(\u0026#39;x\u0026#39;); ylabel(\u0026#39;y\u0026#39;); 计算结果\r1 2 3 \u0026gt;\u0026gt; question1 拟合的参数:a=1.3877,b=-0.0047124,c=1.3623,d=-0.028475 拟合的方程:1.3877*x^3+-0.0047124*x^2+1.3623*x+-0.028475 计算参数\r问题描述\r已知一组观测数据$(x_i,y_i)$见下表，函数的原型为$y=a_1+a_2x^2+a_3e^{-5x^3}+a_4cos(-2x)+a_5x^4$，试用所给数据求出待定系数$a_i$的值。\n$x_i$ $y_i$ $x_i$ $y_i$ 0 6.3700 1.1 5.4941 0.1 6.3888 1.3 5.9187 0.3 6.2056 1.8 4.5944 0.4 5.8676 2.1 1.1440 0.7 4.7256 2.6 -11.4326 0.9 4.8990 3.0 30.0009 0.95 5.0383 程序设计\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 %question2.m x0=[10;10;10;10;10];%初始参数猜测值 x1=linspace(0,3,5000);%生成x数据点 xdata=[0;0.1;0.3;0.4;0.7;0.9;0.95;1.1;1.3;1.8;2.1;2.6;3.0];%生成x数据点 ydata=[6.3700;6.3888;6.2056;5.8676;4.7256;4.8990;5.0383;5.4941;5.9187;4.5944;1.1440;-11.4326;30.0009];%生成对应的y数据点 %定义函数模型 fun=@(x,xdata)x(1)+x(2)*xdata.^2+x(3)*exp(-5*xdata.^3)+x(4)*cos(-2*xdata)+x(5)*xdata.^4; [x,resnorm]=lsqcurvefit(fun,x0,xdata,ydata); %打印出拟合的参数 disp([\u0026#39;拟合的参数:a1=\u0026#39;,num2str(x(1)),\u0026#39;,a2=\u0026#39;,num2str(x(2)),\u0026#39;,a3=\u0026#39;,num2str(x(3)),\u0026#39;,a4=\u0026#39;,num2str(x(4)),\u0026#39;,a5=\u0026#39;,num2str(x(5))]); %绘制图形 plot(x1,fun(x,x1),\u0026#39;r-\u0026#39;,xdata,ydata,\u0026#39;b--\u0026#39;); %添加图例和标题 legend(\u0026#39;拟合曲线\u0026#39;,\u0026#39;原始数据\u0026#39;); title(\u0026#39;使用lsqcurvefit拟合的曲线\u0026#39;); xlabel(\u0026#39;x\u0026#39;); ylabel(\u0026#39;y\u0026#39;); 计算结果\r1 2 \u0026gt;\u0026gt; question2 拟合的参数:a1=9.4777,a2=-16.5136,a3=22.4145,a4=-25.3911,a5=2.3676 面积计算\r问题描述\r已知欧洲某个国家的地图如下图所示，为了计算出它的国土面积，首先对地图进行如下测量：以由西向东方为$x$轴，由南向北方为$y$轴，选择方便的原点，并将从最西边界点到最东边界点在$x$轴上的区间适当的分成若干段，在每个点的$y$方向测出南边界点和北边界点的$y$坐标$y_1$和$y_2$，这样就得到了表中所示的测量数据（单位：mm）。 $x$ $y_1$ $y_2$ $x$ $y_1$ $y_2$ $x$ $y_1$ $y_2$ 7.0 44 44 61 36 117 111.5 32 121 10.5 45 59 68.5 34 118 118 65 122 13.0 47 70 76.5 41 116 123.5 55 116 17.5 50 72 80.5 45 118 136.5 54 83 34 50 93 91 46 118 142 52 81 40.5 38 100 96 43 121 146 50 82 44.5 30 110 101 37 124 150 66 86 48 30 110 104 33 121 157 66 85 56 34 110 106 28 121 158 68 68 数学模型\r事实上，由图像不难看出，该国家的国土面积实际上是由$y_1=f_1(x)$和$y_2=f_2(x)$两条曲线包围起来的。因此，我们只需要求解$f_1(x)$和$f_2(x)$，然后通过积分$\\int\\limits_{7.0}^{56}(f_2(x)-f_1(x))dx $就可以得到。\n程序设计\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 %question3.m %定义初始值 x=[7.0,10.5,13.0,17.5,34,40.5,44.5,48,56,61,68.5,76.5,80.5,91,96,101,104,106,111.5,118,123.5,136.5,142,146,150,157,158]; y1=[44,45,47,50,50,38,30,30,34,36,34,41,45,46,43,37,33,28,32,65,55,54,52,50,66,66,68]; y2=[44,59,70,72,93,100,110,110,110,117,118,116,118,118,121,124,121,121,121,122,116,83,81,82,86,85,68]; %定义微分间隔 d=0.01; dx=7:d:158; %插值 y1_=interp1(x,y1,dx,\u0026#39;linear\u0026#39;); y2_=interp1(x,y2,dx,\u0026#39;linear\u0026#39;); s=sum(y2_-y1_)*d/18^2*1600; %输出结果 fprintf(\u0026#39;The sum of the differences between the two curves is %.2f km^2\\n\u0026#39;,s); plot(x,y1,\u0026#39;b\u0026#39;,x,y2,\u0026#39;b\u0026#39;); 计算结果\r1 2 \u0026gt;\u0026gt; question3 The sum of the differences between the two curves is 42414.81 km^2 ","date":"2024-08-05T00:00:00Z","permalink":"https://www.zhaocloud.work/p/matlab_matching/","title":"第十二周作业-拟合"},{"content":"北邮Matlab选修 Week 14 数值积分\r问题描述\r编写复化自适应步长辛普森积分函数，实现对函数$f(x)=\\frac{sin(x)}{x}$在区间$[1,5]$的积分，并分析各分段积分区间的自适应步长值。\n程序设计\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 %simpson.m function [I, steps] = simpson(fun, a, b, tol, varargin) % 复化自适应步长辛普森公式求解数值积分，并返回区间划分步长 % 输入参数： % fun：被积函数 % a, b：积分区间的端点 % tol：误差容忍度 % varargin：函数fun的附加参数 % 输出参数： % I：求得的积分值 % steps：区间划分的步长列表 if nargin \u0026lt; 4 || isempty(tol) tol = 1e-4; % 默认误差容忍度 end [I, steps] = adaptiveSimpson(fun, a, b, tol, a, b, varargin{:}); end function [I, steps] = adaptiveSimpson(fun, a, b, tol, fullA, fullB, varargin) % 自适应辛普森积分辅助函数 % 使用递归方法自动调整积分步长以满足误差要求，并记录每次划分的中点 c = (a + b) / 2; S1 = simpsonRule(fun, a, b, varargin{:}); S2 = simpsonRule(fun, a, c, varargin{:}) + simpsonRule(fun, c, b, varargin{:}); if abs(S1 - S2) \u0026lt; 15 * tol I = S2 + (S2 - S1) / 15; steps = c; else [IL, stepsL] = adaptiveSimpson(fun, a, c, tol/2, fullA, fullB, varargin{:}); [IR, stepsR] = adaptiveSimpson(fun, c, b, tol/2, fullA, fullB, varargin{:}); I = IL + IR; steps = [stepsL, c, stepsR]; end % 如果是最外层调用，则添加区间的起始和结束点 if a == fullA \u0026amp;\u0026amp; b == fullB steps = [a, steps, b]; end end function S = simpsonRule(fun, a, b, varargin) % 辛普森规则计算函数 c = (a + b) / 2; fa = feval(fun, a, varargin{:}); fb = feval(fun, b, varargin{:}); fc = feval(fun, c, varargin{:}); S = (b - a) * (fa + 4*fc + fb) / 6; end 计算结果\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 %test1.m % 定义函数 fun = @(x) sin(x)./x; % 求积分，例如从 0 到 10，误差容忍度为 1e-5 [I, steps] = simpson(fun, 1, 5, 1e-5); % 显示结果 fprintf(\u0026#39;积分结果为: %f\\n\u0026#39;, I); y_values = arrayfun(fun, steps); % 绘制步长点 plot(steps, y_values, \u0026#39;o-\u0026#39;, \u0026#39;LineWidth\u0026#39;, 2); title(\u0026#39;自适应步长展示\u0026#39;); grid on; % 增加注释 for i = 1:length(steps) text(steps(i), y_values(i), sprintf(\u0026#39;(%0.2f, %0.2f)\u0026#39;, steps(i), y_values(i)), ... \u0026#39;VerticalAlignment\u0026#39;, \u0026#39;bottom\u0026#39;, \u0026#39;HorizontalAlignment\u0026#39;, \u0026#39;right\u0026#39;); end 1 2 \u0026gt;\u0026gt; test1 积分结果为: 0.603848 ","date":"2024-08-05T00:00:00Z","permalink":"https://www.zhaocloud.work/p/matlab_integration/","title":"第十四周作业-数值积分"},{"content":"北邮Matlab选修 Week 5 牛顿迭代法\r问题描述\r用牛顿法求解二元方程组的根。\n数学模型\r在$(x_k,y_k)$处将将$f_1$和$f_2$分别进行泰勒级数展开，并取线性部分作为近似，如下：\n令泰勒级数展开的近似式等于零，得到线性方程组：\n表示为矩阵形式：\n求解这个线性方程组，可以得到迭代增量，进而更新将$x$和$y$的值：\n重复这个过程，直到满足收敛条件（例如，两次迭代的差的绝对值小于某个预定的容忍度）或达到最大迭代次数。\n程序设计\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 %newton_method.m function X=newton_method() X=[1;1]; %取初始解 N=100; %最大迭代次数 e=1e-5; %设置误差限 syms x y; func1=x^2*cos(2*x)+y^2*sin(2*y)-1; %定义函数1 func2=x^3+y^3-6*cos(2*x*y)+1; %定义函数2 d_func1_1=diff(func1,x); d_func2_1=diff(func2,x); d_func1_2=diff(func1,y); d_func2_2=diff(func2,y); f_out=f(X,func1,func2); for i=1:N d_f_out=d_f(X,d_func1_1,d_func2_1,d_func1_2,d_func2_2); %计算雅各比矩阵 det_x=-inv(d_f_out)*f_out; %计算x的变化量 X=X+det_x; %x更新 f_out=f(X,func1,func2); %计算非线性方程组 if norm(det_x)\u0026lt;e break; end end X=double(X); end function [out] = f(X,func1,func2) syms x y; out(1,1)=subs(func1,{x,y},{X(1,1),X(2,1)}); out(2,1)=subs(func2,{x,y},{X(1,1),X(2,1)}); end function d_out= d_f(X,d_func1_1,d_func2_1,d_func1_2,d_func2_2) syms x y; d_out(1,1)=double(subs(d_func1_1,{x,y},{X(1,1),X(2,1)})); d_out(2,1)=double(subs(d_func2_1,{x,y},{X(1,1),X(2,1)})); d_out(1,2)=double(subs(d_func1_2,{x,y},{X(1,1),X(2,1)})); d_out(2,2)=double(subs(d_func2_2,{x,y},{X(1,1),X(2,1)})); end end 计算结果\r1 2 3 4 5 6 \u0026gt;\u0026gt; newton_method ans = 0.6219 0.9685 ","date":"2024-08-05T00:00:00Z","permalink":"https://www.zhaocloud.work/p/matlab_newton/","title":"第五周作业-牛顿迭代法"},{"content":"北邮Matlab选修 Week 4 插值问题（两道题）\r绘图\r问题描述\r一个学校想要建一个钟楼，需要对其进行建模，将方程$ z=\\frac{1}{x^2+y^2} $ 作为模型，编写一个绘制钟楼的脚本。$ x $、$ y $的取值范围是$ -0.75 \\leq x \\leq +0.75 $，数据间隔为$0.05$。设置坐标轴，使$ x $、$ y $的所有区域可见。并且$z$的范围在0到300之间。使用surf()绘制图像。\n程序设计\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 %question1.m function question1() x_min = -0.75; x_max = 0.75; y_min = -0.75; y_max = 0.75; interval = 0.05; x = x_min:interval:x_max; y = y_min:interval:y_max; [X, Y] = meshgrid(x, y); Z = 1 ./ (X.^2 + Y.^2); Z_max = 300; xlim([x_min x_max]); ylim([y_min y_max]); zlim([0 Z_max]); surf(X, Y, Z); end 计算结果\r1 \u0026gt;\u0026gt; question1 机器零件刷漆用料计算问题\r问题描述\r编写程序讨论下面两种数列生成算法的稳定性\n数列$P_n=[1,\\frac{1}{3},\\frac{1}{9},\\frac{1}{27},\\cdots]$\n设$P_0=1$，递推公式$P_n=\\frac{1}{3} \\times P_{n-1}$ 设$P_0=1$，$P_1=\\frac{1}{3}$，递推公式$P_n=\\frac{10}{3} \\times P_{n-1} - P_{n-2}$ 程序设计\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 %question2.m function question2() p0 = 1; N = 35; tolerance = 0.01; flag2 = N + 1; pn1 = zeros(1, N); pn1(1) = p0; for n = 1:N-1 pn1(n+1) = (1/3) * pn1(n); end pn2 = zeros(1, N); pn2(1) = p0; pn2(2) = 1/3; for n = 1:N-2 pn2(n+2) = (10/3) * pn2(n+1) - pn2(n); end for n = 1:N if abs(pn1(n) - pn2(n)) \u0026gt; tolerance flag2 = n; break; end end hold on; plot(1:N, pn1, \u0026#39;r\u0026#39;); plot(1:N, pn2, \u0026#39;b\u0026#39;); plot(flag2, pn1(flag2), \u0026#39;o\u0026#39;, \u0026#39;MarkerSize\u0026#39;, 10, \u0026#39;MarkerFaceColor\u0026#39;, \u0026#39;yellow\u0026#39;); xlabel(\u0026#39;n\u0026#39;); ylabel(\u0026#39;p[n]\u0026#39;); legend(\u0026#39;pn1\u0026#39;,\u0026#39;pn2\u0026#39;,\u0026#39;Point\u0026#39;); end 计算结果\r1 \u0026gt;\u0026gt; question2 ","date":"2024-08-04T00:00:00Z","permalink":"https://www.zhaocloud.work/p/matlab_interrupt/","title":"第四周作业-插值问题"},{"content":"北邮Matlab选修 Week 2 贷款问题\r问题描述\r你想买一套 600 万元的房子，首付 30% ,当前的年贷款利率是 4.8%。\n若选择等额本金方式还款。\r贷20年，每月的还款额是多少？ 贷款期间，总共付了多少利息 若选择等额本息方式还款\r贷20年，每月的还款额是多少？ 贷款期间，总共付了多少利息 数学模型\r等额本金方式还款\r每月还款额\n等额本金还款法每月还款金额由两部分组成：\n$$ 本金部分+利息部分 $$\n本金部分是固定的，因此：\n$$ 每月还款的本金=\\frac{贷款总额}{贷款月数} $$ $$ 每月利息=剩余本金×月利率 $$\n每月还款额公式：\n$$ 每月还款额=每月本金+每月利息 $$\n其中，\n$$ 每月本金=\\frac{贷款总额}{贷款月数} $$ $$ 每月利息=剩余本金×月利率 $$\n总利息\n总利息可以通过逐月累加每月的利息来计算。\n等额本息方式还款\r每月还款额\n等额本息还款法每月还款金额是固定的，计算公式如下：（等比数列求和公式） $$ 每月还款额=\\frac{贷款本金×月利率×(1+月利率)^n}{(1+月利率)^n-1} $$ 其中， $$ n是贷款月数 $$\n总利息 $$ 总利息=贷款总额×贷款月利率×贷款月数-贷款本金 $$\n程序设计\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 %程序入口 function Loan(totalMoney, loanYears, yearlyInterestRate) totalLoan=(1-0.3)*totalMoney; loanMonths=12*loanYears; monthlyInterestRate=yearlyInterestRate/12; fprintf(\u0026#39;等额本金方式还款：\\n\u0026#39;); equalPrincipal(totalLoan, loanMonths, monthlyInterestRate); fprintf(\u0026#39;等额本息方式还款：\\n\u0026#39;); equalPrincipalAndInterest(totalLoan, loanMonths, monthlyInterestRate); end % 等额本金方式还款 function equalPrincipal(totalLoan, loanMonths, monthlyInterestRate) monthlyPrincipal = totalLoan / loanMonths; totalInterest = 0; results = zeros(loanMonths, 3); for i = 1:loanMonths remainingPrincipal = totalLoan - (i-1) * monthlyPrincipal; monthlyInterest = remainingPrincipal * monthlyInterestRate; totalInterest = totalInterest + monthlyInterest; monthlyPayment = monthlyPrincipal + monthlyInterest; results(i, :) = [i, monthlyPayment, monthlyInterest]; end writematrix(results, \u0026#39;equalPrincipal.csv\u0026#39;); fprintf(\u0026#39;总利息：%f\\n\u0026#39;, totalInterest); end % 等额本息方式还款 function equalPrincipalAndInterest(totalLoan, loanMonths, monthlyInterestRate) monthlyPayment = (totalLoan * monthlyInterestRate * (1 + monthlyInterestRate)^loanMonths) / ((1 + monthlyInterestRate)^loanMonths - 1); totalInterest = loanMonths * monthlyPayment - totalLoan; results = [monthlyPayment, totalInterest]; writematrix(results, \u0026#39;equalPrincipalAndInterest.csv\u0026#39;); fprintf(\u0026#39;总利息：%f\\n\u0026#39;,totalInterest); end 计算结果\r1 2 3 4 5 \u0026gt;\u0026gt; Loan(6000000,20,0.048) 等额本金方式还款： 总利息：2024400.000000 等额本息方式还款： 总利息：2341491.296042 ","date":"2024-08-03T00:00:00Z","permalink":"https://www.zhaocloud.work/p/matlab_loan/","title":"第二周作业-贷款问题"},{"content":"北邮Matlab选修 Week 3 涂料计算\r问题描述\r如图所示的磁盘，半径为R，高度为h，它有8个圆柱形的孔，每个孔的半径为r，这可能是一个需要刷漆的机器零件，刷完后再与其他零件进行组装。在设计这台机器的过程中，我们可能需要知道这个磁盘的重量和它所需的油漆量。机器的重量和油漆量是各个零件的总和。由于磁盘的重量与它的体积成正比，油漆量与它的“润湿面积”成正比，所以我们需要知道这个磁盘的体积和面积。\n请编写一个函数，用于求该磁盘的体积和面积，并用一个实例对编写的函数进行测试。\n数学模型\r体积计算\r原始磁盘体积\n磁盘是一个圆柱体，其体积$V_{disk}$可以通过以下公式计算：\n$$ V_{disk}=\\pi R^2h $$\n其中，$R$是磁盘的半径，$h$是磁盘的高度。\n孔的体积\n每个孔也是一个圆柱体，其体积$V_{hole}$可以通过以下公式计算：\n$$ V_{hole}=\\pi r^2 h $$\n其中：$r$是孔的半径。\n实际磁盘体积\n实际磁盘体积 $V_{actual}$ 是原始体积减去总孔体积：\n$$ V_{actual}=V_{disk}-totalholes \\times V_{hole} $$\n润湿面积计算\r原始磁盘表面积\n磁盘的表面积包括两个底面和一个侧面，其表面积 $S_{disk}$ 可以通过以下公式计算：\n$$ S_{disk}=2\\pi R^2 + 2\\pi Rh $$\n其中，$R$ 是磁盘的半径，$h$是磁盘的高度。\n孔的侧面积\n每个孔的侧面积$S_{holeside}$可以通过以下公式计算：\n$$ S_{holeside} = 2 \\pi r h $$\n这里不考虑孔的底面，因为它们位于磁盘内部，不会增加润湿面积，其中，$r$是孔的半径。\n孔的底面和顶面面积\n每个孔的侧面积$S_{topbuttom}$可以通过以下公式计算：\n$$ S_{topbuttom} = 2 \\pi r^2 $$\n实际磁盘体积\n最后，实际润湿面积$S_{actual}$是原始表面积加上总孔侧面积减去总孔底面和顶面面积：\n$$ S_{actual}=S_{disk}+totalholes \\times (S_{holeside} - S_{topbuttom}) $$\n程序设计\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 function [volume, surface_area] = disk_volume_area(R, h, r) % R - 磁盘的半径 % h - 磁盘的高度 % r - 每个孔的半径 % n_holes - 孔的数量 n_holes=8; % 计算原始磁盘的体积 original_volume = pi * R^2 * h; % 计算原始磁盘的表面积（包括两个底面和一个侧面） original_surface_area = 2 * pi * R^2 + 2 * pi * R * h; % 计算每个孔的体积 hole_volume = pi * r^2 * h; % 计算每个孔的侧面积（不包括底面，因为底面在磁盘内部，不参与润湿） hole_side_area = 2 * pi * r * h; %计算每个孔的顶、底面积 hole_top_buttom_area = 2 * pi * r * r; % 计算所有孔的总体积 total_hole_volume = n_holes * hole_volume; % 计算所有孔的顶、底面积总和 total_hole_side_area = n_holes * hole_side_area; % 计算所有孔的侧面积总和 total_hole_top_buttom_area = n_holes * hole_top_buttom_area; % 计算磁盘的实际体积（减去孔的体积） volume = original_volume - total_hole_volume; % 计算磁盘的实际润湿面积 surface_area = original_surface_area + total_hole_side_area - total_hole_top_buttom_area; end 计算结果\r1 2 3 4 5 6 7 8 \u0026gt;\u0026gt; R=10; \u0026gt;\u0026gt; h=5; \u0026gt;\u0026gt; r=2; \u0026gt;\u0026gt; [volume, surface_area] = disk_volume_area(R, h, r); \u0026gt;\u0026gt; fprintf(\u0026#39;磁盘的体积为: %f\\n\u0026#39;, volume); 磁盘的体积为: 1068.141502 \u0026gt;\u0026gt; fprintf(\u0026#39;磁盘的润湿面积为: %f\\n\u0026#39;, surface_area); 磁盘的润湿面积为: 1244.070691 ","date":"2024-08-03T00:00:00Z","permalink":"https://www.zhaocloud.work/p/matlab_diskvolume/","title":"第三周作业-涂料计算"},{"content":"Mineraft-Java Edition 简单联机教程\r情况1:玩家们在同一网络范围内\r比如:连接同一个路由器 Or 同时连接同一所学校的校园网\n1.1 进入待联机世界\r1 2 3 4 Step1:点按Esc键进入游戏菜单 Step2:点击对局域网开放 Step3:点击创造一个局域网世界 （在较高版本上可以自定义端口，在较低版本端口号会显示在聊天框中） Notice:不论如何，请记住这个端口号！！！\n1.2 回到桌面（不要退出MC）\r1 2 Step1:按组合键Windows+R进入运行，在弹出的框中输入cmd，回车运行 Step2:在弹出的界面输入ipconfig，浏览内容，找到\u0026#34;IPv4 地址\u0026#34;一行，记住后面形如xxx.xxx.xxx.xxx的部分 1.3 回到MC\r1 Step1:在好友的电脑上点击多人游戏————直接连接，并输入\u0026#34;IPv4 地址:端口号\u0026#34;连接进入 举例说明:\r1 2 3 在上述 1.1 步骤中获取（设置）的端口号为25565 在上述 1.2 步骤中获取的IPv4地址为192.168.3.5 那么好友就应当输入192.168.3.5:25565 情况2:玩家们不在同一网络范围内\r比如:在两个不同的城市\n2.1 进入待联机世界\r1 同 1.1 P.S.:如果端口可以自定义，建议 25565\n2.2 寻找端口映射服务器\r1 2 3 4 5 6 7 8 9 10 11 Step1:建议访问https://panel.chmlfrp.cn/login注册并实名 Step2:在 隧道管理————隧道列表 页面下点击\u0026#34;添加隧道\u0026#34;，选一个节点（建议海外节点） Step3:点击，在\u0026#34;内网端口\u0026#34;一栏填写 1.1 获取（设置）的端口号，点击确定，保存 Step4*:第一次使用的用户，点击软件下载，下载对应客户端并解压 Step5:在 隧道管理————配置文件 页面下点击\u0026#34;节点选择\u0026#34;,选择刚刚创建的节点， 点击\u0026#34;复制配置文件\u0026#34; Step6:在客户端文件中找到\u0026#34;frpc.ini\u0026#34;，右键，用记事本打开 Step7:将Step5中生成的配置文件复制到\u0026#34;frpc.ini\u0026#34;文件中，保存， 同时记录server_addr=后面的地址和remote_port=后面的端口号记录下来 Step8:关闭记事本，打开\u0026#34;frpc.ini\u0026#34;所在的文件夹，右键\u0026#34;在终端中打开\u0026#34;， 在弹出的框中输入\u0026#34;./frpc\u0026#34;（没有双引号）即可 Notice:\u0026ldquo;frpc.ini\u0026quot;中local_port=后面的端口号必须和 2.1 中的端口号完全相同！！！ Notice:在整个联机过程中不要关闭终端窗口！！！\n2.3 回到MC\r1 Step1:在好友的电脑上点击多人游戏————直接连接，并输入\u0026#34;server_addr:remote_port\u0026#34;连接进入 举例说明:\r1 2 在上述 2.1 步骤中获取（设置）的端口号为25565 在上述 2.2 步骤中的配置文件如下 1 2 3 4 5 6 7 8 9 10 11 12 [common] server_addr = 38.299.130.211 server_port = 7000 tls_enable = false user = XXXXXXXXXXXXXXXXXXX token = ChmlFrpToken [3dyziJm] type = tcp local_ip = 127.0.0.1 local_port = 25565 remote_port = 45486 1 那么好友就应当输入 38.299.130.211:45486 现在，开始你们的MC之旅吧~\r","date":"2024-06-15T00:00:00Z","permalink":"https://www.zhaocloud.work/p/minecraftconnection/","title":"MineCraft联机指南"},{"content":"\r打年糕\rKlee Eat\r咬~\r顶球\r拍瓜\r抓~\r生成表情包\r下载表情包\r","date":"2024-05-23T00:00:00Z","permalink":"https://www.zhaocloud.work/p/qqfavicon/","title":"QQ头像打年糕生成小工具"},{"content":"\r选择背景图片\r图片1\r图片2\r图片3\r图片4\r图片5\r图片6\r图片7\r图片8\r添加文字\r清除画板\r导出图片\r","date":"2024-05-23T00:00:00Z","permalink":"https://www.zhaocloud.work/p/fireflyfavicon/","title":"流萤表情包生成小工具"},{"content":"P1205 [USACO1.2] 方块转换 Transformations\r题目描述\r一块 $n \\times n$ 正方形的黑白瓦片的图案要被转换成新的正方形图案。写一个程序来找出将原始图案按照以下列转换方法转换成新图案的最小方式：\n转 $90\\degree$：图案按顺时针转 $90\\degree$。\n转 $180\\degree$：图案按顺时针转 $180\\degree$。\n转 $270\\degree$：图案按顺时针转 $270\\degree$。\n反射：图案在水平方向翻转（以中央铅垂线为中心形成原图案的镜像）。\n组合：图案在水平方向翻转，然后再按照 $1 \\sim 3$ 之间的一种再次转换。\n不改变：原图案不改变。\n无效转换：无法用以上方法得到新图案。\n如果有多种可用的转换方法，请选择序号最小的那个。\n只使用上述 $7$ 个中的一个步骤来完成这次转换。\n输入格式\r第一行一个正整数 $n$。\n然后 $n$ 行，每行 $n$ 个字符，全部为 @ 或 -，表示初始的正方形。\n接下来 $n$ 行，每行 $n$ 个字符，全部为 @ 或 -，表示最终的正方形。\n输出格式\r单独的一行包括 $1 \\sim 7$ 之间的一个数字（在上文已描述）表明需要将转换前的正方形变为转换后的正方形的转换方法。\n样例 #1\r样例输入 #1\r1 2 3 4 5 6 7 3 @-@ --- @@- @-@ @-- --@ 样例输出 #1\r1 1 提示\r【数据范围】\n对于 $100%$ 的数据，$1\\le n \\le 10$。\n题目翻译来自 NOCOW。\nUSACO Training Section 1.2\n解答\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; struct matrix { char a[12][12]; int dim; }A,B; matrix Real_Reflex(matrix x) { int n = x.dim; for(int i=0;i\u0026lt;n;i++) { for(int j=0;j\u0026lt;n/2;j++) { int temp = x.a[i][j]; x.a[i][j] = x.a[i][n-j-1]; x.a[i][n-j-1] = temp; } } return x; } matrix Real_Rorate(matrix x) { int n = x.dim; for(int i=0;i\u0026lt;n/2;i++) { for(int j=i;j\u0026lt;n-i-1;j++) { int temp = x.a[i][j]; x.a[i][j] = x.a[n-j-1][i]; x.a[n-j-1][i] = x.a[n-i-1][n-j-1]; x.a[n-i-1][n-j-1] = x.a[j][n-i-1]; x.a[j][n-i-1] = temp; } } return x; } int Are_they_the_same(matrix X) { int n = X.dim; int flag = 0; for(int i=0;i\u0026lt;n;i++) { for(int j=0;j\u0026lt;n;j++) { if(X.a[i][j]!=B.a[i][j]) { flag = 1; break; } } } if(flag==0) { return 1; } return 0; } int main() { int n; cin\u0026gt;\u0026gt;n; A.dim = n; B.dim = n; for(int i=0;i\u0026lt;n;i++)//cin the matrixA { for(int j=0;j\u0026lt;n;j++) { cin\u0026gt;\u0026gt;A.a[i][j]; } } for(int i=0;i\u0026lt;n;i++)//cin the matrixB { for(int j=0;j\u0026lt;n;j++) { cin\u0026gt;\u0026gt;B.a[i][j]; } } if(Are_they_the_same(Real_Rorate(A))==1)//rorate 90 degrees { cout\u0026lt;\u0026lt;\u0026#34;1\u0026#34;; return 0; } else if(Are_they_the_same(Real_Rorate(Real_Rorate(A))))//rorate 180 degrees { cout\u0026lt;\u0026lt;\u0026#34;2\u0026#34;; return 0; } else if(Are_they_the_same(Real_Rorate(Real_Rorate(Real_Rorate(A)))))//rorate 270 degrees { cout\u0026lt;\u0026lt;\u0026#34;3\u0026#34;; return 0; } else if(Are_they_the_same(Real_Reflex(A))==1)//reflex { cout\u0026lt;\u0026lt;\u0026#34;4\u0026#34;; return 0; } else if(Are_they_the_same(Real_Rorate(Real_Reflex(A)))==1)//rorate 90 degrees and reflex { cout\u0026lt;\u0026lt;\u0026#34;5\u0026#34;; return 0; } else if(Are_they_the_same(Real_Rorate(Real_Rorate(Real_Reflex(A))))==1)//rorate 180 degrees and reflex { cout\u0026lt;\u0026lt;\u0026#34;5\u0026#34;; return 0; } else if(Are_they_the_same(Real_Rorate(Real_Rorate(Real_Rorate(Real_Reflex(A))))))//rorate 270 degrees and reflex { cout\u0026lt;\u0026lt;\u0026#34;5\u0026#34;; return 0; } else if(Are_they_the_same(A))//no rorate { cout\u0026lt;\u0026lt;\u0026#34;6\u0026#34;; return 0; } else { cout\u0026lt;\u0026lt;\u0026#34;7\u0026#34;; return 0; } return 0; } ","date":"2023-10-24T00:00:00Z","permalink":"https://www.zhaocloud.work/p/transformations/","title":"P1205 [USACO1.2] 方块转换 Transformations"},{"content":"北邮VC++实验题 结构数组使用\r题目描述\r编写一个记录5个学生的姓名、性别、年龄和学号的程序，要求使用结构数组表示学生信息，用for循环获得键盘输入的学生记录的数据，所有数据输入完毕后，将5个学生的信息在屏幕上输出。\n输入格式\r按表格行列格式输出，每行输出一个学生的信息，按照姓名、性别、年龄、学号的顺序，各列信息左对齐，各信息占10位。\n样例 #1\r样例输入 #1\r1 2 3 4 5 John male 18 2016211001 Kim male 18 2016211002 David male 18 2016211003 Marry female 18 2016211004 Anna female 18 2016211005 样例输出#1\r1 2 3 4 5 John male 18 2016211001 Kim male 18 2016211002 David male 18 2016211003 Marry female 18 2016211004 Anna female 18 2016211005 样例 #2\r样例输入 #2\r1 2 3 4 5 a male 18 001 b female 19 002 c male 20 003 d female 21 004 e male 22 005 样例输出 #2\r1 2 3 4 5 a male 18 001 b female 19 002 c male 20 003 d female 21 004 e male 22 005 提示\r采用格式输出，程序中包含#include，并使用setiosflags(ios::left)和setw(n)。\n解答\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; int main() { struct stu{ char name[10]={0}; char sex[10]={0}; int age; char number[10]={0}; }student[5]; for(int i=0;i\u0026lt;5;i++) scanf(\u0026#34;%s %s %d %s\u0026#34;,\u0026amp;student[i].name,\u0026amp;student[i].sex,\u0026amp;student[i].age,\u0026amp;student[i].number); for(int i=0;i\u0026lt;5;i++) { /*printf(\u0026#34;\u0026#34;%-10s%-10s%-10d%-10s\u0026#34;,x,x,x,x);*/ cout\u0026lt;\u0026lt;setiosflags(ios::left); cout\u0026lt;\u0026lt;setw(10)\u0026lt;\u0026lt;student[i].name\u0026lt;\u0026lt;setw(10)\u0026lt;\u0026lt;student[i].sex\u0026lt;\u0026lt;setw(10)\u0026lt;\u0026lt;student[i].age\u0026lt;\u0026lt;setw(10)\u0026lt;\u0026lt;student[i].number\u0026lt;\u0026lt;endl; } return 0; } ","date":"2023-10-24T00:00:00Z","permalink":"https://www.zhaocloud.work/p/array_of_structures/","title":"结构数组的使用-PTA"},{"content":"北邮VC++实验题 老王赛马\r题目描述\r赛马是一古老的游戏，早在公元前四世纪的中国，处在诸侯割据的状态，历史上称为“战国时期”。在魏国作官的孙膑，因为受到同僚庞涓的迫害，被齐国使臣救出后，到达齐国国都。\n赛马是当时最受齐国贵族欢迎的娱乐项目。上至国王，下到大臣，常常以赛马取乐，并以重金赌输赢。田忌多次与国王及其他大臣赌输赢，屡赌屡输。一天他赛马又输了，回家后闷闷不乐。孙膑安慰他说：“下次有机会带我到马场看看，也许我能帮你。”\n孙膑仔细观察后发现，田忌的马和其他人的马相差并不远，只是策略运用不当，以致失败。\n比赛前田忌按照孙膑的主意，用上等马鞍将下等马装饰起来，冒充上等马，与齐王的上等马比赛。第二场比赛，还是按照孙膑的安排，田忌用自己的上等马与国王的中等马比赛，在一片喝彩中，只见田忌的马竟然冲到齐王的马前面，赢了第二场。关键的第三场，田忌的中等马和国王的下等马比赛，田忌的马又一次冲到国王的马前面，结果二比一，田忌赢了国王。\n就是这么简单，现在老王也来赛一赛马。假设每匹马都有恒定的速度，所以速度大的马一定比速度小的马先到终点（没有意外！！）。不允许出现平局。最后谁赢的场数多于一半(不包括一半)，谁就是赢家(可能没有赢家)。老王有N(1≤N≤1000)匹马参加比赛。对手的马的数量与渊子马的数量一样，并且知道所有的马的速度。聪明的你来预测一下这场世纪之战的结果，看看老王能否赢得比赛。\n输入格式\r输入有多组测试数据。 每组测试数据包括3行： 第一行输入N(1≤N≤1000)。表示马的数量。 第二行有N个整型数字，即老王的N匹马的速度。 第三行有N个整型数字，即对手的N匹马的速度。 当N为0时退出。\n输出格式\r若通过聪明的你精心安排，如果老王能赢得比赛，那么输出“YES”。 否则输出“NO”。\n样例\r样例输入\r1 2 3 4 5 6 7 5 2 3 3 4 5 1 2 3 4 5 4 2 2 1 2 2 2 3 1 0 样例输出\r1 2 YES NO 解答\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n = 1; int flag=1; while (n) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); if (n == 0) return 0; else if (flag!=1){cout\u0026lt;\u0026lt;endl;} flag=0; int a[n], b[n], c[n]; for (int i = 0; i \u0026lt; n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); for (int i = 0; i \u0026lt; n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;b[i]); sort(a, a + n); sort(b, b + n); int win = 0; for (int i = n - 1; i \u0026gt;= 1; i--) { for (int j = i - 1; j \u0026gt;= 0; j--) { if (a[i] \u0026gt; b[j]){ win++; b[j] = a[i]; break;} } } if (win \u0026gt; n / 2) printf(\u0026#34;YES\u0026#34;); else printf(\u0026#34;NO\u0026#34;); } } ","date":"2023-10-24T00:00:00Z","permalink":"https://www.zhaocloud.work/p/wang_racing/","title":"老王赛马-PTA"},{"content":"北邮VC++实验题 明明的随机数\r题目描述\r明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用 计算机生成了N个1到1000之间的随机整数（N≤100），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然 后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。\n输入格式\r有2行，第1行为1个正整数，表示所生成的随机数的个数：N 第2行有N个用空格隔开的正整数，为所产生的随机数。\n输出格式\r也是2行，第1行为1个正整数M，表示不相同的随机数的个数。第2行为M个用空格隔开的正整数，为从小到大排好序的不相同的随机数。\n样例\r样例输入\r1 2 10 20 40 32 67 40 20 89 300 400 15 样例输出\r1 2 8 15 20 32 40 67 89 300 400 解答\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int n,total=0; short int a[1000000]={0}; cin\u0026gt;\u0026gt;n; int z; for(int i=1;i\u0026lt;=n;i++) { cin\u0026gt;\u0026gt;z; if(a[z]==0)total++; a[z]++; } cout\u0026lt;\u0026lt;total\u0026lt;\u0026lt;endl; int zzz=1; for(int i=0;i\u0026lt;1000000;i++) { if(a[i]!=0){ if(zzz==1){cout\u0026lt;\u0026lt;i;zzz=0;} else cout\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;i; } } } ","date":"2023-10-24T00:00:00Z","permalink":"https://www.zhaocloud.work/p/mingming_random/","title":"明明的随机数-PTA"},{"content":"北邮VC++实验题 破解简单密码\r题目描述\r假设老王原来一个BBS上的密码为zvbo941987,为了方便记忆，他通过一种算法把这个密码变换成YUANzi1987，这个密码是他的名字和出生年份，怎么忘都忘不了，而且可以明目张胆地放在显眼的地方而不被别人知道真正的密码。 他是这么变换的，大家都知道手机上的字母： 1\u0026ndash;1， abc\u0026ndash;2, def\u0026ndash;3, ghi\u0026ndash;4, jkl\u0026ndash;5, mno\u0026ndash;6, pqrs\u0026ndash;7, tuv\u0026ndash;8 wxyz\u0026ndash;9, 0\u0026ndash;0,就这么简单，老王把密码中出现的小写字母都变成对应的数字，数字和其他的符号都不做变换，声明：密码中没有空格，而密码中出现的大写字母则边成小写之后往后移一位，如：X，先边成小写，再往后移一位，不就是y了嘛，简单吧。记住，z往后移是a哦。\n输入格式\r输入包括多个测试数据，输入是一个明文，密码长度不超过80个字符。\n输出格式\r输出老王真正的密文。\n样例\r样例输入\r1 YUANzi1987 输出样例\r1 zvbo941987 解答\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; int main() { int a[27]={0}; char s[500]; cin.getline(s,500); for(int i=0;i\u0026lt;=strlen(s);i++) { if(s[i]\u0026gt;=\u0026#39;a\u0026#39;\u0026amp;\u0026amp;s[i]\u0026lt;=\u0026#39;c\u0026#39;) { s[i]=\u0026#39;2\u0026#39;; } if(s[i]\u0026gt;=\u0026#39;d\u0026#39;\u0026amp;\u0026amp;s[i]\u0026lt;=\u0026#39;f\u0026#39;) { s[i]=\u0026#39;3\u0026#39;; } if(s[i]\u0026gt;=\u0026#39;g\u0026#39;\u0026amp;\u0026amp;s[i]\u0026lt;=\u0026#39;i\u0026#39;) { s[i]=\u0026#39;4\u0026#39;; } if(s[i]\u0026gt;=\u0026#39;j\u0026#39;\u0026amp;\u0026amp;s[i]\u0026lt;=\u0026#39;l\u0026#39;) { s[i]=\u0026#39;5\u0026#39;; } if(s[i]\u0026gt;=\u0026#39;m\u0026#39;\u0026amp;\u0026amp;s[i]\u0026lt;=\u0026#39;o\u0026#39;) { s[i]=\u0026#39;6\u0026#39;; } if(s[i]\u0026gt;=\u0026#39;p\u0026#39;\u0026amp;\u0026amp;s[i]\u0026lt;=\u0026#39;s\u0026#39;) { s[i]=\u0026#39;7\u0026#39;; } if(s[i]\u0026gt;=\u0026#39;t\u0026#39;\u0026amp;\u0026amp;s[i]\u0026lt;=\u0026#39;v\u0026#39;) { s[i]=\u0026#39;8\u0026#39;; } if(s[i]\u0026gt;=\u0026#39;w\u0026#39;\u0026amp;\u0026amp;s[i]\u0026lt;=\u0026#39;z\u0026#39;) { s[i]=\u0026#39;9\u0026#39;; } if(s[i]\u0026gt;=\u0026#39;A\u0026#39;\u0026amp;\u0026amp;s[i]\u0026lt;=\u0026#39;Z\u0026#39;) { s[i]=s[i]+33; if(s[i]==\u0026#39;z\u0026#39;+1)s[i]=\u0026#39;a\u0026#39;; } } puts(s); } ","date":"2023-10-24T00:00:00Z","permalink":"https://www.zhaocloud.work/p/solve_basic_pwd/","title":"破解简单密码-PTA"},{"content":"北邮VC++实验题 将十六进制数转换为二进制数\r题目描述\r将十六进制数转换为二进制数。\n输入格式\r输入一个16进制数。\n输出格式：\r输出二进制数。\n样例\r样例输入\r1 23 样例输出\r1 100011 解答\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;bitset\u0026gt; //十六进制转二进制 using namespace std; int main() { int n,i=0,s[10000]; scanf(\u0026#34;%x\u0026#34;,\u0026amp;n); while(n!=0) { s[i]=n%2; //printf(\u0026#34;%d\\n\u0026#34;,s[i]); n/=2; i++; } for(int j=i-1;j\u0026gt;=0;j--) { printf(\u0026#34;%d\u0026#34;,s[j]); } if(i==0) { printf(\u0026#34;0\u0026#34;); } } ","date":"2023-10-24T00:00:00Z","permalink":"https://www.zhaocloud.work/p/hex_to_bin/","title":"十六进制转二进制-PTA"},{"content":"北邮VC++实验题 判别水果颜色\r题目描述\r现在有一堆水果，苹果红色，香蕉黄色，西瓜绿色，其余紫色。 当输入一种水果名字，要输入其对应的颜色。\n输入格式\r输入水果名字，如：苹果。\n输出格式\r输出颜色，如：红色。\n样例\r输入样例\r1 苹果 输出样例\r1 红色 解答\r1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; //判断水果颜色 using namespace std; int main() { string s; cin\u0026gt;\u0026gt;s; if(s==\u0026#34;苹果\u0026#34;)cout\u0026lt;\u0026lt;\u0026#34;红色\u0026#34;; else if(s==\u0026#34;香蕉\u0026#34;)cout\u0026lt;\u0026lt;\u0026#34;黄色\u0026#34;; else if(s==\u0026#34;西瓜\u0026#34;)cout\u0026lt;\u0026lt;\u0026#34;绿色\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;紫色\u0026#34;; } ","date":"2023-10-24T00:00:00Z","permalink":"https://www.zhaocloud.work/p/fruit_color/","title":"水果颜色-PTA"},{"content":"北邮VC++实验题 校园歌手大赛新规则\r题目描述\r8号选手参加校园歌手大赛，编程读入20个整数(0 - 100之间)并存入数组中做为评委打分。最后得分计算规则：先计算20个数的平均分，然后去掉所有与平均分相差10分以上的分数，最后把剩下的分数再取平均做为最后得分。如果没有剩下分数，此次打分无效。\n输入格式\r输入20个整数。\n输出格式\r输出三行，具体详见输出样例。\n样例\r样例输入 #1\r1 86 87 83 70 99 94 78 89 86 80 97 84 90 87 95 87 84 99 84 95 样例输出 #1\r1 2 3 所有评委平均分:87.700分. 不合格得分:70 99 99. 最后得分:87.412分. 样例输入 #2\r1 72 72 73 71 71 72 73 71 71 72 98 98 97 100 99 97 97 99 99 99 样例输出 #2\r1 2 3 所有评委平均分:85.050分. 不合格得分:72 72 73 71 71 72 73 71 71 72 98 98 97 100 99 97 97 99 99 99. 无合格打分. 解答\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;bitset\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; int main() { int zzz=1; double a[20],sum=0,total=20,sum2=0; for(int i=0;i\u0026lt;20;i++) { cin\u0026gt;\u0026gt;a[i]; sum+=a[i]; } sum/=20; printf(\u0026#34;所有评委平均分:%.3lf分.\\n\u0026#34;,sum); cout\u0026lt;\u0026lt;\u0026#34;不合格得分:\u0026#34;; for(int i=0;i\u0026lt;20;i++) { if(fabs(a[i]-sum)\u0026gt;10.00){ if(zzz==1){cout\u0026lt;\u0026lt;a[i];zzz=0;total-=1;} else{cout\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;a[i];total-=1;} } else sum2+=a[i]; } cout\u0026lt;\u0026lt;\u0026#34;.\u0026#34;\u0026lt;\u0026lt;endl; if(total==0){cout\u0026lt;\u0026lt;\u0026#34;无合格打分.\u0026#34;;return 0;} printf(\u0026#34;最后得分:%.3lf分.\u0026#34;,sum2/total); } ","date":"2023-10-24T00:00:00Z","permalink":"https://www.zhaocloud.work/p/singer_rules/","title":"校园歌手大赛新规则-PTA"},{"content":"北京的天\r晴空\r傍晚\r","date":"2023-10-24T00:00:00Z","permalink":"https://www.zhaocloud.work/p/beijing_picture_1/","title":"印象北京"},{"content":"北邮VC++实验题 字母统计\r题目描述\r从键盘输入一行或几行字符串，行数由键盘输入，一行字符串用字符数组存储。请统计所输入的字符串中26个字母（不区分大小写）出现的次数，并将出现次数非零的字母统计结果输出到屏幕上，格式参见样例。如果没有字母，请输出字符串中无字母。\n提示\r注意：输入行数后，换行再输入字符串。\n样例\r样例输入 #1\r1 2 1 I come quickly ! 样例输出 #1\r1 2 3 4 5 6 7 8 9 10 c:2 e:1 i:2 k:1 l:1 m:1 o:1 q:1 u:1 y:1 样例输入 #2\r1 2 1 1 样例输出 #2\r1 字符串中无字母。 解答\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; int main() { int a[27]={0}; char s[500]; int n; cin\u0026gt;\u0026gt;n; cin.get(); for(int i=1;i\u0026lt;=n;i++) { int z; //cin.get(); cin.getline(s,500); z=strlen(s); for(int i=0;i\u0026lt;=z;i++) { if(s[i]\u0026gt;=\u0026#39;a\u0026#39;\u0026amp;\u0026amp; s[i]\u0026lt;=\u0026#39;z\u0026#39;) { a[s[i]-\u0026#39;a\u0026#39;]++; } if(s[i]\u0026gt;=\u0026#39;A\u0026#39;\u0026amp;\u0026amp; s[i]\u0026lt;=\u0026#39;Z\u0026#39;) { a[s[i]-\u0026#39;A\u0026#39;]++; } } } bool bon=false; for(int i=0;i\u0026lt;26;i++) { if(a[i]!=0){cout\u0026lt;\u0026lt;char(i+\u0026#39;a\u0026#39;)\u0026lt;\u0026lt;\u0026#34;:\u0026#34;\u0026lt;\u0026lt;a[i]\u0026lt;\u0026lt;endl;bon=true;} } if(bon==false)cout\u0026lt;\u0026lt;\u0026#34;字符串中无字母。\u0026#34;; } ","date":"2023-10-24T00:00:00Z","permalink":"https://www.zhaocloud.work/p/character_count/","title":"字母统计-PTA"}]